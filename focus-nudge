#!/usr/bin/env bash
# Refocus Shell Nudge - A privacy-first, FLOSS productivity tool
# Copyright (C) 2025 Pablo Gonzalez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Refocus Shell Nudge Script
# This script is executed by cron to send periodic notifications

# Configuration
REFOCUS_DB="$HOME/.local/refocus/refocus.db"
REFOCUS_CONFIG="$HOME/.local/refocus/config.sh"
REFOCUS_LOG_DIR="$HOME/.local/refocus"
REFOCUS_ERROR_LOG="$REFOCUS_LOG_DIR/error.log"

# Set table names
STATE_TABLE="${STATE_TABLE:-state}"
SESSIONS_TABLE="${SESSIONS_TABLE:-sessions}"
PROJECTS_TABLE="${PROJECTS_TABLE:-projects}"

# Load configuration if it exists
if [[ -f "$REFOCUS_CONFIG" ]]; then
    source "$REFOCUS_CONFIG"
else
    # Default values
    REFOCUS_NUDGE_INTERVAL=10
    REFOCUS_LOG_FACILITY="user"
    REFOCUS_LOG_PRIORITY="notice"
fi

# Function to log errors to file
log_error() {
    local error_message="$1"
    local context="${2:-focus-nudge}"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Ensure log directory exists
    mkdir -p "$REFOCUS_LOG_DIR"
    
    # Log to file
    echo "[$timestamp] [$context] $error_message" >> "$REFOCUS_ERROR_LOG"
}

# Function to execute SQLite command with proper error handling
execute_sqlite() {
    local sql_command="$1"
    local context="${2:-focus-nudge}"
    local output
    local exit_code
    
    # Execute SQLite command and capture both output and exit code
    output=$(sqlite3 "$REFOCUS_DB" "$sql_command" 2>&1)
    exit_code=$?
    
    # If there was an error, log it
    if [[ $exit_code -ne 0 ]]; then
        log_error "SQLite error (exit code: $exit_code): $output" "$context"
        log_error "SQL command: $sql_command" "$context"
        return $exit_code
    fi
    
    # Return the output
    echo "$output"
    return 0
}

# Function to log messages
log_message() {
    local message="$1"
    logger -p "$REFOCUS_LOG_FACILITY.$REFOCUS_LOG_PRIORITY" "focus-nudge: $message"
}

# Function to send notification with fallback methods
send_notification() {
    local title="$1"
    local message="$2"
    
    # Try desktop notification first
    if command -v notify-send >/dev/null 2>&1; then
        # Check if we have a display (X11 environment)
        if [[ -n "$DISPLAY" ]] || [[ -n "$WAYLAND_DISPLAY" ]]; then
            if notify-send "$title" "$message" 2>/dev/null; then
                log_message "notification sent via notify-send: $title - $message"
                return 0
            fi
        fi
    fi
    
    # If desktop notifications fail, just log to system log
    # No wall fallback to avoid duplicate/confusing notifications
    log_message "FOCUS NUDGE: $title - $message (desktop notification failed)"
    return 0
}

# Function to check if refocus shell is disabled
check_focus_disabled() {
    if [[ ! -f "$REFOCUS_DB" ]]; then
        log_message "database not found: $REFOCUS_DB"
        return 1
    fi
    
    local focus_disabled
    focus_disabled=$(execute_sqlite "SELECT focus_disabled FROM $STATE_TABLE WHERE id = 1;" "check_focus_disabled")
    
    if [[ $? -ne 0 ]]; then
        log_message "error: failed to query focus_disabled status"
        return 1
    fi
    
    if [[ "$focus_disabled" -eq 1 ]]; then
        log_message "refocus shell is disabled"
        return 1
    fi
    
    return 0
}

# Function to check if nudging is enabled
check_nudging_enabled() {
    if [[ ! -f "$REFOCUS_DB" ]]; then
        log_message "database not found: $REFOCUS_DB"
        return 1
    fi
    
    local nudging_enabled
    nudging_enabled=$(execute_sqlite "SELECT nudging_enabled FROM $STATE_TABLE WHERE id = 1;" "check_nudging_enabled")
    
    if [[ $? -ne 0 ]]; then
        log_message "error: failed to query nudging_enabled status"
        return 1
    fi
    
    if [[ "$nudging_enabled" -eq 0 ]]; then
        log_message "nudging is disabled"
        return 1
    fi
    
    return 0
}

# Function to get current focus status with error handling
get_focus_status() {
    if [[ ! -f "$REFOCUS_DB" ]]; then
        log_message "error: database file not found: $REFOCUS_DB"
        return 1
    fi
    
    local state
    state=$(execute_sqlite "SELECT active, project, start_time, paused, pause_notes FROM $STATE_TABLE WHERE id = 1;" "get_focus_status")
    
    if [[ $? -ne 0 ]]; then
        log_message "error: failed to query focus status from database"
        return 1
    fi
    
    if [[ -z "$state" ]]; then
        log_message "error: could not get focus status - empty result"
        return 1
    fi
    
    IFS='|' read -r active project start_time paused pause_notes <<< "$state"
    
    if [[ "$active" -eq 1 ]] && [[ -n "$project" ]]; then
        # Calculate elapsed time
        local now=$(date +%s 2>/dev/null)
        if [[ $? -ne 0 ]]; then
            log_message "error: failed to get current timestamp"
            return 1
        fi
        
        local start_ts=$(date --date="$start_time" +%s 2>/dev/null)
        if [[ $? -ne 0 ]]; then
            log_message "error: failed to parse start_time: $start_time"
            return 1
        fi
        
        if [[ -n "$start_ts" ]]; then
            local elapsed=$((now - start_ts))
            local minutes=$((elapsed / 60))
            
            # Round to nearest 10-minute interval for clean notification display
            # This ensures notifications show 10m, 20m, 30m, etc. instead of random times
            local rounded_minutes=$(( (minutes + 5) / 10 * 10 ))
            
            # Ensure minimum of 10 minutes
            if [[ $rounded_minutes -lt 10 ]]; then
                rounded_minutes=10
            fi
            
            echo "active|$project|$rounded_minutes"
        else
            echo "active|$project|10"
        fi
    elif [[ "$paused" -eq 1 ]] && [[ -n "$project" ]]; then
        echo "paused|$project|$pause_notes"
    else
        echo "inactive"
    fi
}

# Function to validate database integrity
validate_database() {
    if [[ ! -f "$REFOCUS_DB" ]]; then
        log_message "error: database file not found"
        return 1
    fi
    
    # Check if state table exists and has the expected structure
    local table_exists
    table_exists=$(execute_sqlite "SELECT name FROM sqlite_master WHERE type='table' AND name='state';" "validate_database")
    
    if [[ -z "$table_exists" ]]; then
        log_message "error: state table not found in database"
        return 1
    fi
    
    # Check if state table has required columns
    local has_required_columns
    has_required_columns=$(execute_sqlite "PRAGMA table_info(state);" "validate_database" | grep -c -E "(active|project|start_time|nudging_enabled|focus_disabled)" || echo "0")
    
    if [[ "$has_required_columns" -lt 5 ]]; then
        log_message "error: state table missing required columns"
        return 1
    fi
    
    # Check if state record exists
    local record_exists
    record_exists=$(execute_sqlite "SELECT COUNT(*) FROM $STATE_TABLE WHERE id = 1;" "validate_database")
    
    if [[ "$record_exists" -eq 0 ]]; then
        log_message "error: no state record found in database"
        return 1
    fi
    
    return 0
}

# Main function
main() {
    log_message "nudge script started"
    
    # Validate database integrity first
    if ! validate_database; then
        log_message "error: database validation failed, exiting"
        exit 1
    fi
    
    # Check if refocus shell is disabled
    if ! check_focus_disabled; then
        log_message "refocus shell is disabled, exiting"
        exit 0
    fi
    
    # Check if nudging is enabled
    if ! check_nudging_enabled; then
        log_message "nudging is disabled, exiting"
        exit 0
    fi
    
    # Get current focus status
    local status
    status=$(get_focus_status)
    
    if [[ $? -ne 0 ]]; then
        log_message "error: could not get focus status, exiting"
        exit 1
    fi
    
    # Send appropriate notification
    if [[ "$status" == "inactive" ]]; then
        # Send idle notification to remind user to start focusing
        if send_notification "Focus Reminder" "You're not focusing on any project."; then
            log_message "idle notification sent successfully"
        else
            log_message "error: failed to send idle notification"
        fi
    elif [[ "$status" == "paused"* ]]; then
        IFS='|' read -r state project pause_notes <<< "$status"
        if [[ "$state" == "paused" ]]; then
            local message="Session paused: $project"
            if [[ -n "$pause_notes" ]]; then
                message="$message - $pause_notes"
            fi
            send_notification "Focus Paused" "$message"
            log_message "paused session notification sent for project: $project"
        fi
    else
        IFS='|' read -r state project minutes <<< "$status"
        if [[ "$state" == "active" ]]; then
            if send_notification "Focus Reminder" "You're focusing on: $project (${minutes}m elapsed)"; then
                log_message "active notification sent successfully for project: $project"
            else
                log_message "error: failed to send active notification for project: $project"
            fi
        fi
    fi
    
    log_message "nudge script completed successfully"
}

# Run main function
main "$@" 