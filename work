#!/usr/bin/env bash
# Work Manager - A privacy-first, FLOSS productivity tool
# Copyright (C) 2025 Pablo Gonzalez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Trap Ctrl+C to show abort message
trap 'echo ""; echo "Operation aborted"; exit 1' INT

DB_DEFAULT="$HOME/.local/work/timelog.db"
DB="$DB_DEFAULT"
WORK_DATA_PATH="$HOME/.local/work"

STATE_TABLE="state"
SESSIONS_TABLE="sessions"

# Verbose mode flag
VERBOSE=false

# Function to print verbose messages
verbose_echo() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "$1"
    fi
}

# Function to get the current prompt or fallback to default
get_current_prompt() {
    # Always use the standard Ubuntu prompt as fallback since current PS1 is broken
    echo '${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
}

# Function to save current prompt to temporary file
save_current_prompt() {
    local original_prompt_file="/tmp/work_original_prompt_$$"
    
    # Save current PS1 to temporary file
    local current_prompt
    current_prompt=$(get_current_prompt)
    
    cat > "$original_prompt_file" << EOF
# Original prompt saved by work manager
PS1='$current_prompt'
EOF
    verbose_echo "Original prompt saved to temporary file: $original_prompt_file"
}

# Function to set work prompt using temporary files
set_work_prompt() {
    local project="$1"
    local work_prompt_file="/tmp/work_active_prompt_$$"
    
    # Save current prompt first
    save_current_prompt
    
    # Create work prompt with indicator at the front
    cat > "$work_prompt_file" << EOF
# Work manager prompt - active work session
PS1='‚è≥ [$project] \${debian_chroot:+(\$debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
EOF
    
    # Update database with prompt file location
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET prompt_file = '$work_prompt_file' WHERE id = 1;"
    
    # Update current terminal prompt using the function
    # Try to call update-prompt function if available
    if type update-prompt >/dev/null 2>&1; then
        update-prompt
        verbose_echo "Work prompt set for: $project"
        verbose_echo "Current terminal prompt updated - press Enter to see the change."
    else
        # Fallback: export PS1 directly
        export PS1='‚è≥ ['$project'] ${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        verbose_echo "Work prompt set for: $project"
        verbose_echo "Note: New terminals will show the work indicator. Current terminal updated."
    fi
    
    # Always show the tip about update-prompt
    echo "Tip: Run 'update-prompt' to update the current terminal prompt"
}

# Function to restore original prompt
restore_original_prompt() {
    local original_prompt_file="/tmp/work_original_prompt_$$"
    local default_prompt_file="/tmp/work_default_prompt_$$"
    
    # Clear prompt file from database
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET prompt_file = NULL WHERE id = 1;"
    
    # Create default prompt file
    cat > "$default_prompt_file" << 'EOF'
# Default Ubuntu prompt (no work session active)
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
EOF
    
    # Update database with default prompt file
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET prompt_file = '$default_prompt_file' WHERE id = 1;"
    
    # Update current terminal prompt using the function
    # Try to call update-prompt function if available
    if type update-prompt >/dev/null 2>&1; then
        update-prompt
        verbose_echo "Original prompt restored"
        verbose_echo "Current terminal prompt updated - press Enter to see the change."
    else
        # Fallback: export PS1 directly
        if [[ -f "$original_prompt_file" ]]; then
            # Source the original prompt to get the PS1 value
            source "$original_prompt_file"
        else
            # Use default Ubuntu prompt
            export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        fi
        verbose_echo "Original prompt restored"
        verbose_echo "Note: New terminals will show the normal prompt. Current terminal updated."
    fi
    
    # Always show the tip about update-prompt
    echo "Tip: Run 'update-prompt' to update the current terminal prompt"
}

# Function to get current prompt from database
get_current_prompt_from_db() {
    local prompt_file
    prompt_file=$(sqlite3 "$DB" "SELECT prompt_file FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    
    if [[ -n "$prompt_file" ]] && [[ -f "$prompt_file" ]]; then
        # Source the prompt file to get PS1
        source "$prompt_file"
        return 0
    else
        # No active session or prompt file doesn't exist, use default
        export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        return 1
    fi
}

# Function to check if work is properly installed
check_installation() {
    # Check if we're running from an installed location
    local script_path="$(readlink -f "$0")"
    local script_dir="$(dirname "$script_path")"
    
    # Check if this is an installed version
    if [[ "$script_dir" == "/usr/local/bin" ]] || [[ "$script_dir" == "$HOME/.local/bin" ]] || [[ "$script_dir" == "/usr/bin" ]]; then
        return 0  # Installed
    else
        return 1  # Not installed
    fi
}

# Function to call installer
call_installer() {
    local action="$1"
    local installer_path=""
    
    # Try to find the setup script
    if [[ -f "./setup.sh" ]]; then
        installer_path="./setup.sh"
    elif [[ -f "$(dirname "$0")/setup.sh" ]]; then
        installer_path="$(dirname "$0")/setup.sh"
    else
        echo "Error: Could not find setup.sh"
        exit 1
    fi
    
    echo "Calling setup script for: $action"
    # Always run interactive when called from work script
    bash "$installer_path" "$action"
}

# Check installation and database status
if ! check_installation; then
    echo "Work manager is not installed."
    echo "Running setup script to set up work manager..."
    call_installer "install"
    exit 0
elif ! [ -f "$DB" ]; then
    echo "Database does not exist. Initializing..."
    call_installer "init"
fi

# Check if notify-send is available (will be installed by setup script if needed)
if ! command -v notify-send >/dev/null 2>&1; then
    echo "Warning: notify-send not available. Run './setup.sh deps' to install dependencies."
fi

function work_on() {
    local project="$1"
    local start_time
    start_time=$(date -Iseconds)

    # Check if work manager is disabled
    local work_disabled
    work_disabled=$(sqlite3 "$DB" "SELECT work_disabled FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    if [[ "$work_disabled" -eq 1 ]]; then
        echo "‚ùå Work manager is disabled. Run 'work enable' to re-enable."
        exit 1
    fi

    # Check if already active
    active=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;")
    if [[ "$active" -eq 1 ]]; then
        echo "Work already active. Run 'work off' before switching."
        exit 1
    fi

    sqlite3 "$DB" "UPDATE $STATE_TABLE SET active = 1, project = '$project', start_time = '$start_time' WHERE id = 1;"
    echo "Started work on: $project"

    # Set work prompt
    set_work_prompt "$project"

    if command -v notify-send >/dev/null 2>&1; then
    notify-send "Started work on: $project"
    fi
}

function work_off() {
    local now
    now=$(date -Iseconds)

    state=$(sqlite3 "$DB" "SELECT active, project, start_time FROM $STATE_TABLE WHERE id = 1;")
    IFS='|' read -r active project start_time <<< "$state"

    if [[ "$active" -ne 1 ]]; then
        echo "No active work session."
        exit 1
    fi

    start_ts=$(date --date="$start_time" +%s)
    end_ts=$(date --date="$now" +%s)
    duration=$((end_ts - start_ts))

    sqlite3 "$DB" \
        "INSERT INTO $SESSIONS_TABLE (project, start_time, end_time, duration_seconds) \
         VALUES ('$project', '$start_time', '$now', $duration);"

    sqlite3 "$DB" "UPDATE $STATE_TABLE SET active = 0, project = NULL, start_time = NULL, prompt_file = NULL WHERE id = 1;"
    echo "Stopped work on: $project (Duration: $((duration / 60)) min)"

    # Restore original prompt
    restore_original_prompt

    if command -v notify-send >/dev/null 2>&1; then
    notify-send "Stopped work on: $project"
    fi
}

function work_status() {
    state=$(sqlite3 "$DB" "SELECT active, project, start_time FROM $STATE_TABLE WHERE id = 1;")
    IFS='|' read -r active project start_time <<< "$state"

    if [[ "$active" -eq 1 ]]; then
        now=$(date +%s)
        start_ts=$(date --date="$start_time" +%s)
        elapsed=$((now - start_ts))
        echo "‚è≥ Working on: $project ‚Äî $(($elapsed / 60))m elapsed"
    else
        echo "‚úÖ Not currently tracking work."
    fi
}

function work_reset() {
    echo "This will delete all work data and reset the database."
    echo "Are you sure you want to continue? (y/N)"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        # Stop any active session first
        state=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
        if [[ "$state" -eq 1 ]]; then
            echo "Stopping active session..."
            work_off
        fi
        
        # Call installer to reset database
        call_installer "reset"
    else
        echo "Reset cancelled."
    fi
}

function work_enable() {
    # Check if work manager is disabled
    local work_disabled
    work_disabled=$(sqlite3 "$DB" "SELECT work_disabled FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    
    if [[ "$work_disabled" -eq 1 ]]; then
        sqlite3 "$DB" "UPDATE $STATE_TABLE SET work_disabled = 0 WHERE id = 1;"
        echo "‚úÖ Work manager enabled"
        
        if command -v notify-send >/dev/null 2>&1; then
            notify-send "Work Manager Enabled" "Work tracking and nudging are now active."
        fi
    else
        echo "‚úÖ Work manager is already enabled"
    fi
}

function work_disable() {
    # Stop any active session first
    state=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    if [[ "$state" -eq 1 ]]; then
        echo "Stopping active session..."
        work_off
    fi
    
    # Disable work manager
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET work_disabled = 1 WHERE id = 1;"
    echo "üö´ Work manager disabled"
    echo "No work sessions or nudging will be available until you run 'work enable'"
    
    if command -v notify-send >/dev/null 2>&1; then
        notify-send "Work Manager Disabled" "Work tracking and nudging are now inactive."
    fi
}

function work_test_nudge() {
    # Manual nudge for testing
    if [[ ! -f "$WORK_DATA_PATH/work-nudge" ]]; then
        echo "‚ùå Nudge script not found. Run installer to set up nudging."
        return 1
    fi
    
    echo "Sending manual nudge..."
    "$WORK_DATA_PATH/work-nudge"
}

function work_export() {
    local output_file="$1"
    
    # Default output file if none specified
    if [[ -z "$output_file" ]]; then
        output_file="work-export-$(date +%Y%m%d_%H%M%S).json"
    fi
    
    # Check if database exists
    if [[ ! -f "$DB" ]]; then
        echo "‚ùå Database not found. Run installer to initialize."
        return 1
    fi
    
    echo "üì§ Exporting work data to: $output_file"
    
    # Export state table
    local state_data=$(sqlite3 "$DB" -json "SELECT * FROM state WHERE id = 1;" 2>/dev/null)
    
    # Export sessions table
    local sessions_data=$(sqlite3 "$DB" -json "SELECT * FROM sessions ORDER BY start_time;" 2>/dev/null)
    
    # Create JSON structure
    cat > "$output_file" << EOF
{
  "export_info": {
    "export_date": "$(date -Iseconds)",
    "version": "1.0",
    "database_path": "$DB"
  },
  "state": $state_data,
  "sessions": $sessions_data
}
EOF
    
    if [[ $? -eq 0 ]]; then
        echo "‚úÖ Export completed successfully"
        echo "üìÅ File: $output_file"
        verbose_echo "Exported $(echo "$sessions_data" | jq 'length' 2>/dev/null || echo "unknown number of") sessions"
    else
        echo "‚ùå Export failed"
        return 1
    fi
}

function work_import() {
    local input_file="$1"
    
    if [[ -z "$input_file" ]]; then
        echo "‚ùå Please specify a JSON file to import"
        echo "Usage: work import <filename.json>"
        return 1
    fi
    
    if [[ ! -f "$input_file" ]]; then
        echo "‚ùå File not found: $input_file"
        return 1
    fi
    
    echo "üì• Importing work data from: $input_file"
    
    # Validate JSON structure
    if ! jq empty "$input_file" 2>/dev/null; then
        echo "‚ùå Invalid JSON file"
        return 1
    fi
    
    # Check if required fields exist
    if ! jq -e '.state and .sessions' "$input_file" >/dev/null 2>&1; then
        echo "‚ùå Invalid export format. Missing required fields."
        return 1
    fi
    
    # Backup current database
    local backup_file="$DB.backup.$(date +%Y%m%d_%H%M%S)"
    if [[ -f "$DB" ]]; then
        cp "$DB" "$backup_file"
        verbose_echo "Created backup: $backup_file"
    fi
    
    # Clear existing data
    sqlite3 "$DB" "DELETE FROM sessions;"
    sqlite3 "$DB" "DELETE FROM state WHERE id > 1;"
    
    # Import state data
    local state_json=$(jq -r '.state[0]' "$input_file" 2>/dev/null)
    if [[ -n "$state_json" ]] && [[ "$state_json" != "null" ]]; then
        local active=$(echo "$state_json" | jq -r '.active // 0')
        local project=$(echo "$state_json" | jq -r '.project // null')
        local start_time=$(echo "$state_json" | jq -r '.start_time // null')
        local prompt_file=$(echo "$state_json" | jq -r '.prompt_file // null')
        local nudging_enabled=$(echo "$state_json" | jq -r '.nudging_enabled // 1')
        local work_disabled=$(echo "$state_json" | jq -r '.work_disabled // 0')
        
        sqlite3 "$DB" "UPDATE state SET active = $active, project = '$project', start_time = '$start_time', prompt_file = '$prompt_file', nudging_enabled = $nudging_enabled, work_disabled = $work_disabled WHERE id = 1;"
        verbose_echo "Imported state data"
    fi
    
    # Import sessions data
    local sessions_count=$(jq -r '.sessions | length' "$input_file" 2>/dev/null)
    if [[ "$sessions_count" -gt 0 ]]; then
        jq -r '.sessions[] | [.project, .start_time, .end_time, .duration_seconds] | @tsv' "$input_file" 2>/dev/null | while IFS=$'\t' read -r project start_time end_time duration; do
            sqlite3 "$DB" "INSERT INTO sessions (project, start_time, end_time, duration_seconds) VALUES ('$project', '$start_time', '$end_time', $duration);"
        done
        verbose_echo "Imported $sessions_count sessions"
    fi
    
    echo "‚úÖ Import completed successfully"
    echo "üìä Imported $sessions_count sessions"
    
    if [[ -f "$backup_file" ]]; then
        echo "üíæ Backup created: $backup_file"
    fi
}

function work_help() {
    echo "Usage:"
    echo "  work on \"project\"      Start tracking"
    echo "  work off                Stop tracking"
    echo "  work status             Show current session"
    echo "  work enable             Enable work manager"
    echo "  work disable            Disable work manager"
    echo "  work test-nudge         Send manual nudge (testing)"
    echo "  work export [file]      Export data to JSON"
    echo "  work import <file>      Import data from JSON"
    echo "  work reset              Reset database (delete all data)"
    echo ""
    echo "Options:"
    echo "  --verbose               Show detailed output"
    echo ""
    echo "Examples:"
    echo "  work export                    # Export to timestamped file"
    echo "  work export my-data.json      # Export to specific file"
    echo "  work import backup.json       # Import from JSON file"
    echo "  work test-nudge               # Test nudging functionality"
}

# Parse arguments
ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --verbose)
            VERBOSE=true
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            work_help
            exit 1
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac
done

# Restore positional arguments
set -- "${ARGS[@]}"

case "$1" in
    on)
        shift
        work_on "$@"
        ;;
    off)
        work_off
        ;;
    status)
        work_status
        ;;
    enable)
        work_enable
        ;;
    disable)
        work_disable
        ;;
    test-nudge)
        work_test_nudge
        ;;
    export)
        shift
        work_export "$@"
        ;;
    import)
        shift
        work_import "$@"
        ;;
    reset)
        work_reset
        ;;
    *)
        work_help
        ;;
esac
