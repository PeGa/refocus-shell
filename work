#!/usr/bin/env bash

# Trap Ctrl+C to show abort message
trap 'echo ""; echo "Operation aborted"; exit 1' INT

DB_DEFAULT="$HOME/.local/work/timelog.db"
DB="$DB_DEFAULT"
WORK_DATA_PATH="$HOME/.local/work"

STATE_TABLE="state"
SESSIONS_TABLE="sessions"

# Function to get the current prompt or fallback to default
get_current_prompt() {
    # Always use the standard Ubuntu prompt as fallback since current PS1 is broken
    echo '${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
}

# Function to save current prompt
save_current_prompt() {
    local original_prompt_file="$WORK_DATA_PATH/original_prompt.sh"
    
    # Save current PS1 if not already saved
    if [[ ! -f "$original_prompt_file" ]]; then
        local current_prompt
        current_prompt=$(get_current_prompt)
        
        cat > "$original_prompt_file" << EOF
# Original prompt saved by work manager
PS1='$current_prompt'
EOF
        echo "Original prompt saved"
    fi
}

# Function to set work prompt
set_work_prompt() {
    local project="$1"
    local prompt_file="$WORK_DATA_PATH/prompt.sh"
    
    # Save current prompt first
    save_current_prompt
    
    # Create work prompt with indicator at the front
    cat > "$prompt_file" << EOF
# Work manager prompt - active work session
PS1='⏳ [$project] \${debian_chroot:+(\$debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
EOF
    
    # Export PS1 to current terminal
    export PS1='⏳ ['$project'] ${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
    
    echo "Work prompt set for: $project"
    echo "Note: New terminals will show the work indicator. Current terminal updated."
}

# Function to restore original prompt
restore_original_prompt() {
    local original_prompt_file="$WORK_DATA_PATH/original_prompt.sh"
    local prompt_file="$WORK_DATA_PATH/prompt.sh"
    
    if [[ -f "$original_prompt_file" ]]; then
        # Restore original prompt
        cp "$original_prompt_file" "$prompt_file"
        echo "Original prompt restored"
    else
        # No original prompt saved, use default Ubuntu prompt
        cat > "$prompt_file" << 'EOF'
# Default Ubuntu prompt (no work session active)
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
EOF
        echo "Default Ubuntu prompt set"
    fi
    
    # Export original PS1 to current terminal
    if [[ -f "$original_prompt_file" ]]; then
        # Source the original prompt to get the PS1 value
        source "$original_prompt_file"
    else
        # Use default Ubuntu prompt
        export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
    fi
    
    echo "Note: New terminals will show the normal prompt. Current terminal updated."
}

# Function to check if work is properly installed
check_installation() {
    # Check if we're running from an installed location
    local script_path="$(readlink -f "$0")"
    local script_dir="$(dirname "$script_path")"
    
    # Check if this is an installed version
    if [[ "$script_dir" == "/usr/local/bin" ]] || [[ "$script_dir" == "$HOME/.local/bin" ]] || [[ "$script_dir" == "/usr/bin" ]]; then
        return 0  # Installed
    else
        return 1  # Not installed
    fi
}

# Function to call installer
call_installer() {
    local action="$1"
    local installer_path=""
    
    # Try to find the installer script
    if [[ -f "./install.sh" ]]; then
        installer_path="./install.sh"
    elif [[ -f "$(dirname "$0")/install.sh" ]]; then
        installer_path="$(dirname "$0")/install.sh"
    else
        echo "Error: Could not find install.sh"
        exit 1
    fi
    
    echo "Calling installer for: $action"
    # Always run interactive when called from work script
    bash "$installer_path" "$action"
}

# Check installation and database status
if ! check_installation; then
    echo "Work manager is not installed."
    echo "Running installer to set up work manager..."
    call_installer "install"
    exit 0
elif ! [ -f "$DB" ]; then
    echo "Database does not exist. Initializing..."
    call_installer "init"
fi

# Check if notify-send is available (will be installed by installer if needed)
if ! command -v notify-send >/dev/null 2>&1; then
    echo "Warning: notify-send not available. Run './install.sh deps' to install dependencies."
fi

function work_on() {
    local project="$1"
    local start_time
    start_time=$(date -Iseconds)

    # Check if already active
    active=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;")
    if [[ "$active" -eq 1 ]]; then
        echo "Work already active. Run 'work off' before switching."
        exit 1
    fi

    sqlite3 "$DB" "UPDATE $STATE_TABLE SET active = 1, project = '$project', start_time = '$start_time' WHERE id = 1;"
    echo "Started work on: $project"
    
    # Set work prompt
    set_work_prompt "$project"

    if command -v notify-send >/dev/null 2>&1; then
        notify-send "Started work on: $project"
    fi
}

function work_off() {
    local now
    now=$(date -Iseconds)

    state=$(sqlite3 "$DB" "SELECT active, project, start_time FROM $STATE_TABLE WHERE id = 1;")
    IFS='|' read -r active project start_time <<< "$state"

    if [[ "$active" -ne 1 ]]; then
        echo "No active work session."
        exit 1
    fi

    start_ts=$(date --date="$start_time" +%s)
    end_ts=$(date --date="$now" +%s)
    duration=$((end_ts - start_ts))

    sqlite3 "$DB" \
        "INSERT INTO $SESSIONS_TABLE (project, start_time, end_time, duration_seconds) \
         VALUES ('$project', '$start_time', '$now', $duration);"

    sqlite3 "$DB" "UPDATE $STATE_TABLE SET active = 0, project = NULL, start_time = NULL WHERE id = 1;"
    echo "Stopped work on: $project (Duration: $((duration / 60)) min)"
    
    # Restore original prompt
    restore_original_prompt

    if command -v notify-send >/dev/null 2>&1; then
        notify-send "Stopped work on: $project"
    fi
}

function work_status() {
    state=$(sqlite3 "$DB" "SELECT active, project, start_time FROM $STATE_TABLE WHERE id = 1;")
    IFS='|' read -r active project start_time <<< "$state"

    if [[ "$active" -eq 1 ]]; then
        now=$(date +%s)
        start_ts=$(date --date="$start_time" +%s)
        elapsed=$((now - start_ts))
        echo "⏳ Working on: $project — $(($elapsed / 60))m elapsed"
    else
        echo "✅ Not currently tracking work."
    fi
}

function work_reset() {
    echo "This will delete all work data and reset the database."
    echo "Are you sure you want to continue? (y/N)"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        # Stop any active session first
        state=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
        if [[ "$state" -eq 1 ]]; then
            echo "Stopping active session..."
            work_off
        fi
        
        # Call installer to reset database
        call_installer "reset"
    else
        echo "Reset cancelled."
    fi
}

function work_help() {
    echo "Usage:"
    echo "  work on \"project\"      Start tracking"
    echo "  work off                Stop tracking"
    echo "  work status             Show current session"
    echo "  work reset              Reset database (delete all data)"
}

case "$1" in
    on)
        shift
        work_on "$@"
        ;;
    off)
        work_off
        ;;
    status)
        work_status
        ;;
    reset)
        work_reset
        ;;
    *)
        work_help
        ;;
esac
