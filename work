#!/usr/bin/env bash
# Work Manager - A privacy-first, FLOSS productivity tool
# Copyright (C) 2025 Pablo Gonzalez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Trap Ctrl+C to show abort message
trap 'echo ""; echo "Operation aborted"; exit 1' INT

DB_DEFAULT="$HOME/.local/work/timelog.db"
DB="$DB_DEFAULT"
WORK_DATA_PATH="$HOME/.local/work"

STATE_TABLE="state"
SESSIONS_TABLE="sessions"

# Verbose mode flag
VERBOSE=false

# Function to print verbose messages
verbose_echo() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "$1"
    fi
}

# Function to get the current prompt or fallback to default
get_current_prompt() {
    # Always use the standard Ubuntu prompt as fallback since current PS1 is broken
    echo '${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
}

# Function to save current prompt to temporary file
save_current_prompt() {
    local original_prompt_file="/tmp/work_original_prompt_$$"
    
    # Save current PS1 to temporary file
    local current_prompt
    current_prompt=$(get_current_prompt)
    
    cat > "$original_prompt_file" << EOF
# Original prompt saved by work manager
PS1='$current_prompt'
EOF
    verbose_echo "Original prompt saved to temporary file: $original_prompt_file"
}

# Function to set work prompt using temporary files
set_work_prompt() {
    local project="$1"
    local work_prompt_file="/tmp/work_active_prompt_$$"
    
    # Save current prompt first
    save_current_prompt
    
    # Create work prompt with indicator at the front
    cat > "$work_prompt_file" << EOF
# Work manager prompt - active work session
PS1='⏳ [$project] \${debian_chroot:+(\$debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
EOF
    
    # Update database with prompt file location
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET prompt_file = '$work_prompt_file' WHERE id = 1;"
    
    # Update current terminal prompt using the function
    # Try to call update-prompt function if available
    if type update-prompt >/dev/null 2>&1; then
        update-prompt
        verbose_echo "Work prompt set for: $project"
        verbose_echo "Current terminal prompt updated - press Enter to see the change."
    else
        # Fallback: export PS1 directly
        export PS1='⏳ ['$project'] ${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        verbose_echo "Work prompt set for: $project"
        verbose_echo "Note: New terminals will show the work indicator. Current terminal updated."
    fi
    
    # Always show the tip about update-prompt
    echo "Tip: Run 'update-prompt' to update the current terminal prompt"
}

# Function to restore original prompt
restore_original_prompt() {
    local original_prompt_file="/tmp/work_original_prompt_$$"
    local default_prompt_file="/tmp/work_default_prompt_$$"
    
    # Clear prompt file from database
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET prompt_file = NULL WHERE id = 1;"
    
    # Create default prompt file
    cat > "$default_prompt_file" << 'EOF'
# Default Ubuntu prompt (no work session active)
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
EOF
    
    # Update database with default prompt file
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET prompt_file = '$default_prompt_file' WHERE id = 1;"
    
    # Update current terminal prompt using the function
    # Try to call update-prompt function if available
    if type update-prompt >/dev/null 2>&1; then
        update-prompt
        verbose_echo "Original prompt restored"
        verbose_echo "Current terminal prompt updated - press Enter to see the change."
    else
        # Fallback: export PS1 directly
        if [[ -f "$original_prompt_file" ]]; then
            # Source the original prompt to get the PS1 value
            source "$original_prompt_file"
        else
            # Use default Ubuntu prompt
            export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        fi
        verbose_echo "Original prompt restored"
        verbose_echo "Note: New terminals will show the normal prompt. Current terminal updated."
    fi
    
    # Always show the tip about update-prompt
    echo "Tip: Run 'update-prompt' to update the current terminal prompt"
}

# Function to get current prompt from database
get_current_prompt_from_db() {
    local prompt_file
    prompt_file=$(sqlite3 "$DB" "SELECT prompt_file FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    
    if [[ -n "$prompt_file" ]] && [[ -f "$prompt_file" ]]; then
        # Source the prompt file to get PS1
        source "$prompt_file"
        return 0
    else
        # No active session or prompt file doesn't exist, use default
        export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        return 1
    fi
}

# Function to check if work is properly installed
check_installation() {
    # Check if we're running from an installed location
    local script_path="$(readlink -f "$0")"
    local script_dir="$(dirname "$script_path")"
    
    # Check if this is an installed version
    if [[ "$script_dir" == "/usr/local/bin" ]] || [[ "$script_dir" == "$HOME/.local/bin" ]] || [[ "$script_dir" == "/usr/bin" ]]; then
        return 0  # Installed
    else
        return 1  # Not installed
    fi
}

# Function to call installer
call_installer() {
    local action="$1"
    local installer_path=""
    
    # Try to find the setup script
    if [[ -f "./setup.sh" ]]; then
        installer_path="./setup.sh"
    elif [[ -f "$(dirname "$0")/setup.sh" ]]; then
        installer_path="$(dirname "$0")/setup.sh"
    else
        echo "Error: Could not find setup.sh"
        exit 1
    fi
    
    echo "Calling setup script for: $action"
    # Always run interactive when called from work script
    bash "$installer_path" "$action"
}

# Check installation and database status
if ! check_installation; then
    echo "Work manager is not installed."
    echo "Running setup script to set up work manager..."
    call_installer "install"
    exit 0
elif ! [ -f "$DB" ]; then
    echo "Database does not exist. Initializing..."
    call_installer "init"
fi

# Check if notify-send is available (will be installed by setup script if needed)
if ! command -v notify-send >/dev/null 2>&1; then
    echo "Warning: notify-send not available. Run './setup.sh deps' to install dependencies."
fi

function work_on() {
    local project="$1"
    local start_time
    start_time=$(date -Iseconds)

    # Check if work manager is disabled
    local work_disabled
    work_disabled=$(sqlite3 "$DB" "SELECT work_disabled FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    if [[ "$work_disabled" -eq 1 ]]; then
        echo "❌ Work manager is disabled. Run 'work enable' to re-enable."
        exit 1
    fi

    # Check if already active
    active=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;")
    if [[ "$active" -eq 1 ]]; then
        echo "Work already active. Run 'work off' before switching."
        exit 1
    fi

    # Store idle session from last work_off to now (if any)
    local last_work_off_time
    last_work_off_time=$(sqlite3 "$DB" "SELECT last_work_off_time FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    
    if [[ -n "$last_work_off_time" ]] && [[ "$last_work_off_time" != "NULL" ]]; then
        local idle_start_ts
        idle_start_ts=$(date --date="$last_work_off_time" +%s)
        local idle_end_ts
        idle_end_ts=$(date +%s)
        local idle_duration
        idle_duration=$((idle_end_ts - idle_start_ts))
        
        # Only store idle session if duration is significant (> 1 minute)
        if [[ $idle_duration -gt 60 ]]; then
            sqlite3 "$DB" \
                "INSERT INTO $SESSIONS_TABLE (project, start_time, end_time, duration_seconds) \
                 VALUES ('[idle]', '$last_work_off_time', '$start_time', $idle_duration);"
            verbose_echo "Stored idle session: ${idle_duration}s"
        fi
    fi

    # If no project specified, try to use last project
    if [[ -z "$project" ]]; then
        local last_project
        last_project=$(sqlite3 "$DB" "SELECT project FROM $SESSIONS_TABLE WHERE project != '[idle]' ORDER BY end_time DESC LIMIT 1;" 2>/dev/null)
        
        if [[ -n "$last_project" ]]; then
            # Calculate total time for the last project to show in prompt
            local total_project_time
            total_project_time=$(sqlite3 "$DB" "SELECT COALESCE(SUM(duration_seconds), 0) FROM $SESSIONS_TABLE WHERE project = '$last_project' AND project != '[idle]';" 2>/dev/null)
            local total_minutes
            total_minutes=$((total_project_time / 60))
            
            if [[ $total_minutes -gt 0 ]]; then
                echo "Last project was: $last_project (Total: ${total_minutes}m)"
            else
                echo "Last project was: $last_project"
            fi
            echo "Continue? (Y/n)"
            read -r response
            
            if [[ "$response" =~ ^[Nn]$ ]]; then
                echo "Work session aborted — no project specified."
                echo "Run 'work on \"project\"' to start a work session."
                exit 1
            fi
            
            project="$last_project"
        else
            echo "No previous project found."
            echo "Run 'work on \"project\"' to start a work session."
            exit 1
        fi
    fi

    # Calculate total time for this project (including previous sessions)
    local total_project_time
    total_project_time=$(sqlite3 "$DB" "SELECT COALESCE(SUM(duration_seconds), 0) FROM $SESSIONS_TABLE WHERE project = '$project' AND project != '[idle]';" 2>/dev/null)
    local total_minutes
    total_minutes=$((total_project_time / 60))
    
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET active = 1, project = '$project', start_time = '$start_time' WHERE id = 1;"
    
    if [[ $total_minutes -gt 0 ]]; then
        echo "Started work on: $project (Total: ${total_minutes}m)"
    else
        echo "Started work on: $project"
    fi

    # Set work prompt
    set_work_prompt "$project"

    if command -v notify-send >/dev/null 2>&1; then
    notify-send "Started work on: $project"
    fi
}

function work_off() {
    local now
    now=$(date -Iseconds)

    state=$(sqlite3 "$DB" "SELECT active, project, start_time FROM $STATE_TABLE WHERE id = 1;")
    IFS='|' read -r active project start_time <<< "$state"

    if [[ "$active" -ne 1 ]]; then
        echo "No active work session."
        exit 1
    fi

    start_ts=$(date --date="$start_time" +%s)
    end_ts=$(date --date="$now" +%s)
    duration=$((end_ts - start_ts))

    sqlite3 "$DB" \
        "INSERT INTO $SESSIONS_TABLE (project, start_time, end_time, duration_seconds) \
         VALUES ('$project', '$start_time', '$now', $duration);"

    sqlite3 "$DB" "UPDATE $STATE_TABLE SET active = 0, project = NULL, start_time = NULL, prompt_file = NULL, last_work_off_time = '$now' WHERE id = 1;"
    echo "Stopped work on: $project (Duration: $((duration / 60)) min)"

    # Restore original prompt
    restore_original_prompt

    if command -v notify-send >/dev/null 2>&1; then
    notify-send "Stopped work on: $project"
    fi
}

function work_status() {
    state=$(sqlite3 "$DB" "SELECT active, project, start_time FROM $STATE_TABLE WHERE id = 1;")
    IFS='|' read -r active project start_time <<< "$state"

    if [[ "$active" -eq 1 ]]; then
        now=$(date +%s)
        start_ts=$(date --date="$start_time" +%s)
        elapsed=$((now - start_ts))
        
        # Calculate total time for this project (including previous sessions)
        local total_project_time
        total_project_time=$(sqlite3 "$DB" "SELECT COALESCE(SUM(duration_seconds), 0) FROM $SESSIONS_TABLE WHERE project = '$project' AND project != '[idle]';" 2>/dev/null)
        local total_minutes
        total_minutes=$((total_project_time / 60))
        local current_minutes
        current_minutes=$((elapsed / 60))
        
        if [[ $total_minutes -gt 0 ]]; then
            echo "⏳ Working on: $project — ${current_minutes}m elapsed (Total: ${total_minutes}m)"
        else
            echo "⏳ Working on: $project — ${current_minutes}m elapsed"
        fi
    else
        echo "✅ Not currently tracking work."
        
        # Show last work session information (excluding idle sessions)
        local last_session
        last_session=$(sqlite3 "$DB" "SELECT project, end_time, duration_seconds FROM $SESSIONS_TABLE WHERE project != '[idle]' ORDER BY end_time DESC LIMIT 1;" 2>/dev/null)
        
        if [[ -n "$last_session" ]]; then
            IFS='|' read -r last_project last_end_time last_duration <<< "$last_session"
            
            if [[ -n "$last_project" && -n "$last_end_time" ]]; then
                local now_ts
                now_ts=$(date +%s)
                local end_ts
                end_ts=$(date --date="$last_end_time" +%s)
                local time_since
                time_since=$((now_ts - end_ts))
                
                local duration_min
                duration_min=$((last_duration / 60))
                local time_since_min
                time_since_min=$((time_since / 60))
                
                echo "📊 Last session: $last_project (${duration_min}m)"
                echo "⏰ Time since last work: ${time_since_min}m"
            fi
        fi
    fi
}

function work_reset() {
    echo "This will delete all work data and reset the database."
    echo "Are you sure you want to continue? (y/N)"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        # Stop any active session first
        state=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
        if [[ "$state" -eq 1 ]]; then
            echo "Stopping active session..."
            work_off
        fi
        
        # Call installer to reset database
        call_installer "reset"
    else
        echo "Reset cancelled."
    fi
}

function work_enable() {
    # Check if work manager is disabled
    local work_disabled
    work_disabled=$(sqlite3 "$DB" "SELECT work_disabled FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    
    if [[ "$work_disabled" -eq 1 ]]; then
        sqlite3 "$DB" "UPDATE $STATE_TABLE SET work_disabled = 0 WHERE id = 1;"
        echo "✅ Work manager enabled"
        
        if command -v notify-send >/dev/null 2>&1; then
            notify-send "Work Manager Enabled" "Work tracking and nudging are now active."
        fi
    else
        echo "✅ Work manager is already enabled"
    fi
}

function work_disable() {
    # Stop any active session first
    state=$(sqlite3 "$DB" "SELECT active FROM $STATE_TABLE WHERE id = 1;" 2>/dev/null)
    if [[ "$state" -eq 1 ]]; then
        echo "Stopping active session..."
        work_off
    fi
    
    # Disable work manager
    sqlite3 "$DB" "UPDATE $STATE_TABLE SET work_disabled = 1 WHERE id = 1;"
    echo "🚫 Work manager disabled"
    echo "No work sessions or nudging will be available until you run 'work enable'"
    
    if command -v notify-send >/dev/null 2>&1; then
        notify-send "Work Manager Disabled" "Work tracking and nudging are now inactive."
    fi
}

function work_test_nudge() {
    # Manual nudge for testing
    if [[ ! -f "$WORK_DATA_PATH/work-nudge" ]]; then
        echo "❌ Nudge script not found. Run installer to set up nudging."
        return 1
    fi
    
    echo "Sending manual nudge..."
    "$WORK_DATA_PATH/work-nudge"
}

function work_export() {
    local output_file="$1"
    
    # Default output file if none specified
    if [[ -z "$output_file" ]]; then
        output_file="work-export-$(date +%Y%m%d_%H%M%S).json"
    fi
    
    # Check if database exists
    if [[ ! -f "$DB" ]]; then
        echo "❌ Database not found. Run installer to initialize."
        return 1
    fi
    
    echo "📤 Exporting work data to: $output_file"
    
    # Export state table
    local state_data=$(sqlite3 "$DB" -json "SELECT * FROM state WHERE id = 1;" 2>/dev/null)
    
    # Export sessions table
    local sessions_data=$(sqlite3 "$DB" -json "SELECT * FROM sessions ORDER BY start_time;" 2>/dev/null)
    
    # Create JSON structure
    cat > "$output_file" << EOF
{
  "export_info": {
    "export_date": "$(date -Iseconds)",
    "version": "1.0",
    "database_path": "$DB"
  },
  "state": $state_data,
  "sessions": $sessions_data
}
EOF
    
    if [[ $? -eq 0 ]]; then
        echo "✅ Export completed successfully"
        echo "📁 File: $output_file"
        verbose_echo "Exported $(echo "$sessions_data" | jq 'length' 2>/dev/null || echo "unknown number of") sessions"
    else
        echo "❌ Export failed"
        return 1
    fi
}

function work_import() {
    local input_file="$1"
    
    if [[ -z "$input_file" ]]; then
        echo "❌ Please specify a JSON file to import"
        echo "Usage: work import <filename.json>"
        return 1
    fi
    
    if [[ ! -f "$input_file" ]]; then
        echo "❌ File not found: $input_file"
        return 1
    fi
    
    echo "📥 Importing work data from: $input_file"
    
    # Validate JSON structure
    if ! jq empty "$input_file" 2>/dev/null; then
        echo "❌ Invalid JSON file"
        return 1
    fi
    
    # Check if required fields exist
    if ! jq -e '.state and .sessions' "$input_file" >/dev/null 2>&1; then
        echo "❌ Invalid export format. Missing required fields."
        return 1
    fi
    
    # Backup current database
    local backup_file="$DB.backup.$(date +%Y%m%d_%H%M%S)"
    if [[ -f "$DB" ]]; then
        cp "$DB" "$backup_file"
        verbose_echo "Created backup: $backup_file"
    fi
    
    # Clear existing data
    sqlite3 "$DB" "DELETE FROM sessions;"
    sqlite3 "$DB" "DELETE FROM state WHERE id > 1;"
    
    # Import state data
    local state_json=$(jq -r '.state[0]' "$input_file" 2>/dev/null)
    if [[ -n "$state_json" ]] && [[ "$state_json" != "null" ]]; then
        local active=$(echo "$state_json" | jq -r '.active // 0')
        local project=$(echo "$state_json" | jq -r '.project // null')
        local start_time=$(echo "$state_json" | jq -r '.start_time // null')
        local prompt_file=$(echo "$state_json" | jq -r '.prompt_file // null')
        local nudging_enabled=$(echo "$state_json" | jq -r '.nudging_enabled // 1')
        local work_disabled=$(echo "$state_json" | jq -r '.work_disabled // 0')
        
        sqlite3 "$DB" "UPDATE state SET active = $active, project = '$project', start_time = '$start_time', prompt_file = '$prompt_file', nudging_enabled = $nudging_enabled, work_disabled = $work_disabled WHERE id = 1;"
        verbose_echo "Imported state data"
    fi
    
    # Import sessions data
    local sessions_count=$(jq -r '.sessions | length' "$input_file" 2>/dev/null)
    if [[ "$sessions_count" -gt 0 ]]; then
        jq -r '.sessions[] | [.project, .start_time, .end_time, .duration_seconds] | @tsv' "$input_file" 2>/dev/null | while IFS=$'\t' read -r project start_time end_time duration; do
            sqlite3 "$DB" "INSERT INTO sessions (project, start_time, end_time, duration_seconds) VALUES ('$project', '$start_time', '$end_time', $duration);"
        done
        verbose_echo "Imported $sessions_count sessions"
    fi
    
    echo "✅ Import completed successfully"
    echo "📊 Imported $sessions_count sessions"
    
    if [[ -f "$backup_file" ]]; then
        echo "💾 Backup created: $backup_file"
    fi
}

function work_past_add() {
    local project="$1"
    local minutes="$2"
    
    if [[ -z "$project" || -z "$minutes" ]]; then
        echo "❌ Please specify both project name and time in minutes."
        echo "Usage: work past add \"project\" <minutes>"
        exit 1
    fi
    
    # Validate minutes is a number
    if ! [[ "$minutes" =~ ^[0-9]+$ ]]; then
        echo "❌ Time must be a positive integer (minutes)."
        exit 1
    fi
    
    # Calculate timestamps (session ended now, started X minutes ago)
    local end_time
    end_time=$(date -Iseconds)
    local start_time
    start_time=$(date -Iseconds -d "$minutes minutes ago")
    local duration_seconds
    duration_seconds=$((minutes * 60))
    
    # Insert the session
    sqlite3 "$DB" "INSERT INTO $SESSIONS_TABLE (project, start_time, end_time, duration_seconds) VALUES ('$project', '$start_time', '$end_time', $duration_seconds);"
    
    echo "✅ Added past session: $project (${minutes}m)"
    verbose_echo "Session: $start_time to $end_time (${duration_seconds}s)"
}

function work_past_modify() {
    local project="$1"
    local minutes="$2"
    
    if [[ -z "$project" || -z "$minutes" ]]; then
        echo "❌ Please specify both project name and time in minutes."
        echo "Usage: work past modify \"project\" <minutes>"
        exit 1
    fi
    
    # Validate minutes is a number
    if ! [[ "$minutes" =~ ^[0-9]+$ ]]; then
        echo "❌ Time must be a positive integer (minutes)."
        exit 1
    fi
    
    # Check if session exists
    local session_count
    session_count=$(sqlite3 "$DB" "SELECT COUNT(*) FROM $SESSIONS_TABLE WHERE project = '$project';" 2>/dev/null)
    
    if [[ "$session_count" -eq 0 ]]; then
        echo "❌ No session found for project: $project"
        echo "Use 'work past add \"$project\" <minutes>' to create a new session."
        exit 1
    fi
    
    # Calculate new timestamps
    local end_time
    end_time=$(date -Iseconds)
    local start_time
    start_time=$(date -Iseconds -d "$minutes minutes ago")
    local duration_seconds
    duration_seconds=$((minutes * 60))
    
    # Update the session
    sqlite3 "$DB" "UPDATE $SESSIONS_TABLE SET start_time = '$start_time', end_time = '$end_time', duration_seconds = $duration_seconds WHERE project = '$project';"
    
    echo "✅ Modified session: $project (${minutes}m)"
    verbose_echo "Updated session: $start_time to $end_time (${duration_seconds}s)"
}

function work_past_delete() {
    local project="$1"
    
    if [[ -z "$project" ]]; then
        echo "❌ Please specify a project name."
        echo "Usage: work past delete \"project\""
        exit 1
    fi
    
    # Check if session exists
    local session_count
    session_count=$(sqlite3 "$DB" "SELECT COUNT(*) FROM $SESSIONS_TABLE WHERE project = '$project';" 2>/dev/null)
    
    if [[ "$session_count" -eq 0 ]]; then
        echo "❌ No session found for project: $project"
        exit 1
    fi
    
    # Get session details for confirmation
    local session_info
    session_info=$(sqlite3 "$DB" "SELECT start_time, end_time, duration_seconds FROM $SESSIONS_TABLE WHERE project = '$project';" 2>/dev/null)
    IFS='|' read -r start_time end_time duration <<< "$session_info"
    local duration_min
    duration_min=$((duration / 60))
    
    echo "🗑️  Deleting session: $project (${duration_min}m)"
    echo "Session: $start_time to $end_time"
    echo "Are you sure? (y/N)"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        sqlite3 "$DB" "DELETE FROM $SESSIONS_TABLE WHERE project = '$project';"
        echo "✅ Session deleted: $project"
    else
        echo "❌ Deletion cancelled."
    fi
}

function work_past_help() {
    echo "Past Session Management:"
    echo "  work past add \"project\" <minutes>    # Add a past work session"
    echo "  work past modify \"project\" <minutes>  # Modify existing session duration"
    echo "  work past delete \"project\"            # Delete a session"
    echo ""
    echo "Examples:"
    echo "  work past add \"meeting\" 30            # Add 30-minute meeting session"
    echo "  work past modify \"coding\" 120         # Change coding session to 2 hours"
    echo "  work past delete \"old-project\"        # Delete old project session"
    echo ""
    echo "Note: Sessions are created with end time = now, start time = X minutes ago"
}

function work_report_today() {
    local start_time
    start_time=$(date -d "today 00:00" -Iseconds)
    local end_time
    end_time=$(date -Iseconds)
    
    local report_content
    report_content=$(cat <<EOF
# Work Report - Today ($(date +%Y-%m-%d))

EOF
)
    
    # Always export to predefined file
    local export_file="work-report-today-$(date +%Y-%m-%d).md"
    echo "$report_content" > "$export_file"
    work_generate_report "$start_time" "$end_time" >> "$export_file"
    echo "📄 Report exported to: $export_file"
    
    # Also display on screen
    echo "$report_content"
    work_generate_report "$start_time" "$end_time"
}

function work_report_week() {
    local start_time
    start_time=$(date -d "monday this week 00:00" -Iseconds)
    local end_time
    end_time=$(date -Iseconds)
    
    local report_content
    report_content=$(cat <<EOF
# Work Report - This Week ($(date -d "monday this week" +%Y-%m-%d) to $(date +%Y-%m-%d))

EOF
)
    
    # Always export to predefined file
    local export_file="work-report-week-$(date +%Y-%m-%d).md"
    echo "$report_content" > "$export_file"
    work_generate_report "$start_time" "$end_time" >> "$export_file"
    echo "📄 Report exported to: $export_file"
    
    # Also display on screen
    echo "$report_content"
    work_generate_report "$start_time" "$end_time"
}

function work_report_month() {
    local start_time
    start_time=$(date -d "$(date +%Y-%m-01) 00:00" -Iseconds)
    local end_time
    end_time=$(date -Iseconds)
    
    local report_content
    report_content=$(cat <<EOF
# Work Report - This Month ($(date +%Y-%m-01) to $(date +%Y-%m-%d))

EOF
)
    
    # Always export to predefined file
    local export_file="work-report-month-$(date +%Y-%m).md"
    echo "$report_content" > "$export_file"
    work_generate_report "$start_time" "$end_time" >> "$export_file"
    echo "📄 Report exported to: $export_file"
    
    # Also display on screen
    echo "$report_content"
    work_generate_report "$start_time" "$end_time"
}

function work_report_custom() {
    local days_back="$1"
    
    if [[ -z "$days_back" ]]; then
        echo "❌ Please specify number of days back."
        echo "Usage: work report custom <days>"
        echo "Examples:"
        echo "  work report custom 4    # Last 4 days"
        echo "  work report custom 60   # Last 60 days (2 months)"
        exit 1
    fi
    
    # Validate days is a number
    if ! [[ "$days_back" =~ ^[0-9]+$ ]]; then
        echo "❌ Days must be a positive integer."
        exit 1
    fi
    
    local start_time
    start_time=$(date -d "$days_back days ago 00:00" -Iseconds)
    local end_time
    end_time=$(date -Iseconds)
    
    local report_content
    report_content=$(cat <<EOF
# Work Report - Last $days_back Days ($(date -d "$days_back days ago" +%Y-%m-%d) to $(date +%Y-%m-%d))

EOF
)
    
    # Always export to predefined file
    local export_file="work-report-custom-${days_back}days-$(date +%Y-%m-%d).md"
    echo "$report_content" > "$export_file"
    work_generate_report "$start_time" "$end_time" >> "$export_file"
    echo "📄 Report exported to: $export_file"
    
    # Also display on screen
    echo "$report_content"
    work_generate_report "$start_time" "$end_time"
}

function work_generate_report() {
    local start_time="$1"
    local end_time="$2"
    
    # Get all sessions in the time window, ordered by start_time
    local sessions_data
    sessions_data=$(sqlite3 "$DB" "SELECT project, start_time, end_time, duration_seconds FROM $SESSIONS_TABLE WHERE end_time >= '$start_time' AND end_time <= '$end_time' ORDER BY start_time;" 2>/dev/null)
    
    if [[ -z "$sessions_data" ]]; then
        echo "📊 No work sessions found in the specified time period."
        return
    fi
    
    # Calculate total work time (excluding idle sessions)
    local total_work_seconds=0
    local total_idle_seconds=0
    
    # Generate formatted table with fixed column widths
    printf "%-35s | %-12s\n" "Session" "Time"
    printf "%-35s-|-%12s\n" "-----------------------------------" "------------"
    
    # Process sessions in chronological order
    while IFS='|' read -r project start_time_session end_time_session duration; do
        if [[ -n "$project" && -n "$duration" ]]; then
            local hours=$((duration / 3600))
            local minutes=$(((duration % 3600) / 60))
            
            if [[ "$project" == "[idle]" ]]; then
                # Idle session
                total_idle_seconds=$((total_idle_seconds + duration))
                if [[ $hours -gt 0 ]]; then
                    printf "%-35s | %-12s\n" "*Idle*" "*${hours}h ${minutes}m*"
                else
                    printf "%-35s | %-12s\n" "*Idle*" "*${minutes}m*"
                fi
            else
                # Work session
                total_work_seconds=$((total_work_seconds + duration))
                # Truncate long project names to fit in 35 chars
                local display_project="$project"
                if [[ ${#display_project} -gt 33 ]]; then
                    display_project="${display_project:0:30}..."
                fi
                if [[ $hours -gt 0 ]]; then
                    printf "%-35s | %-12s\n" "**$display_project**" "**${hours}h ${minutes}m**"
                else
                    printf "%-35s | %-12s\n" "**$display_project**" "**${minutes}m**"
                fi
            fi
        fi
    done <<< "$sessions_data"
    
    # Convert totals to hours and minutes for display
    local total_work_hours=$((total_work_seconds / 3600))
    local total_work_minutes=$(((total_work_seconds % 3600) / 60))
    local total_idle_hours=$((total_idle_seconds / 3600))
    local total_idle_minutes=$(((total_idle_seconds % 3600) / 60))
    
    echo ""
    echo "**Total Work Time: ${total_work_hours}h ${total_work_minutes}m**"
    echo ""
    echo "*Report generated on $(date)*"
}

function work_report_help() {
    echo "Work Reports:"
    echo "  work report today        # Today's work report (since 00:00)"
    echo "  work report week         # This week's report (since Monday)"
    echo "  work report month        # This month's report (since 1st)"
    echo "  work report custom <N>   # Last N days report"
    echo ""
    echo "Examples:"
    echo "  work report today        # Today's work summary + export"
    echo "  work report week         # This week's summary + export"
    echo "  work report month        # This month's summary + export"
    echo "  work report custom 7     # Last 7 days + export"
    echo ""
    echo "Note: Reports are automatically exported to markdown files:"
    echo "      work-report-today-YYYY-MM-DD.md"
    echo "      work-report-week-YYYY-MM-DD.md"
    echo "      work-report-month-YYYY-MM.md"
    echo "      work-report-custom-Ndays-YYYY-MM-DD.md"
}

function work_help() {
    echo "Usage:"
    echo "  work on \"project\"      Start tracking"
    echo "  work on                 Start tracking (use last project)"
    echo "  work off                Stop tracking"
    echo "  work status             Show current session"
    echo "  work enable             Enable work manager"
    echo "  work disable            Disable work manager"
    echo "  work test-nudge         Send manual nudge (testing)"
    echo "  work export [file]      Export data to JSON"
    echo "  work import <file>      Import data from JSON"
    echo "  work past add \"project\" <minutes>    # Add past session"
    echo "  work past modify \"project\" <minutes>  # Modify session"
    echo "  work past delete \"project\"            # Delete session"
    echo "  work report today        # Today's work report"
    echo "  work report week         # This week's report"
    echo "  work report month        # This month's report"
    echo "  work report custom <N>   # Last N days report"
    echo "  work reset              Reset database (delete all data)"
    echo ""
    echo "Options:"
    echo "  --verbose               Show detailed output"
    echo ""
    echo "Examples:"
    echo "  work on \"my-project\"        # Start tracking specific project"
    echo "  work on                     # Continue with last project"
    echo "  work past add \"meeting\" 30  # Add 30-minute past session"
    echo "  work past modify \"coding\" 120 # Change session to 2 hours"
    echo "  work report today              # Today's work summary"
    echo "  work report custom 7           # Last 7 days"
    echo "  work export                    # Export to timestamped file"
    echo "  work export my-data.json      # Export to specific file"
    echo "  work import backup.json       # Import from JSON file"
    echo "  work test-nudge               # Test nudging functionality"
}

# Parse arguments
ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --verbose)
            VERBOSE=true
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            work_help
            exit 1
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac
done

# Restore positional arguments
set -- "${ARGS[@]}"

case "$1" in
    on)
        shift
        work_on "$@"
        ;;
    off)
        work_off
        ;;
    status)
        work_status
        ;;
    enable)
        work_enable
        ;;
    disable)
        work_disable
        ;;
    test-nudge)
        work_test_nudge
        ;;
    export)
        shift
        work_export "$@"
        ;;
    import)
        shift
        work_import "$@"
        ;;
    past)
        shift
        case "$1" in
            add)
                shift
                work_past_add "$@"
                ;;
            modify)
                shift
                work_past_modify "$@"
                ;;
            delete)
                shift
                work_past_delete "$@"
                ;;
            *)
                work_past_help
                ;;
        esac
        ;;
    report)
        shift
        case "$1" in
            today)
                work_report_today
                ;;
            week)
                work_report_week
                ;;
            month)
                work_report_month
                ;;
            custom)
                shift
                work_report_custom "$@"
                ;;
            *)
                work_report_help
                ;;
        esac
        ;;
    reset)
        work_reset
        ;;
    *)
        work_help
        ;;
esac
